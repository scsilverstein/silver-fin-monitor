import { Database } from '../../types/database.js';
import { 
  EarningsCalendar, 
  EarningsReport, 
  EarningsCallTranscript,
  PolygonEarningsResponse,
  EarningsCalendarFilters,
  EarningsCalendarWithStats 
} from '../../types/earnings.js';
import { logger } from '../../utils/logger.js';

export class EarningsService {
  private db: Database;
  private polygonApiKey: string;
  private baseUrl = 'https://api.polygon.io';

  constructor(db: Database, polygonApiKey: string) {
    this.db = db;
    this.polygonApiKey = polygonApiKey;
  }

  /**
   * Fetch earnings calendar from Polygon.io
   */
  async fetchEarningsCalendar(
    startDate?: string,
    endDate?: string,
    limit: number = 1000
  ): Promise<EarningsCalendar[]> {
    try {
      const params = new URLSearchParams({
        apikey: this.polygonApiKey,
        limit: limit.toString()
      });

      if (startDate) params.append('date.gte', startDate);
      if (endDate) params.append('date.lte', endDate);

      const url = `${this.baseUrl}/v3/reference/earnings?${params}`;
      
      logger.info('Fetching earnings calendar from Polygon', { url: url.replace(this.polygonApiKey, '***') });

      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Polygon API error: ${response.status} ${response.statusText}`);
      }

      const data: PolygonEarningsResponse = await response.json();
      
      if (!data.results) {
        logger.warn('No earnings results from Polygon');
        return [];
      }

      // Transform Polygon data to our format
      const earningsCalendar: EarningsCalendar[] = data.results.map(result => ({
        id: '', // Will be generated by database
        symbol: result.ticker,
        company_name: result.name,
        earnings_date: result.earnings_date || '',
        time_of_day: this.mapTimeOfDay(result.time_of_day),
        fiscal_quarter: result.fiscal_quarter as any,
        fiscal_year: result.fiscal_year,
        eps_estimate: result.eps_estimate,
        revenue_estimate: result.revenue_estimate,
        eps_actual: result.eps_actual,
        revenue_actual: result.revenue_actual,
        importance_rating: result.importance,
        confirmed: result.confirmed || false,
        status: result.eps_actual !== undefined ? 'reported' : 'scheduled',
        market_cap: result.market_cap,
        previous_close: result.previous_close,
        data_source: 'polygon',
        external_id: `${result.ticker}_${result.earnings_date}`,
        last_updated: new Date().toISOString(),
        created_at: new Date().toISOString()
      }));

      return earningsCalendar;
    } catch (error) {
      logger.error('Error fetching earnings calendar', error);
      throw error;
    }
  }

  /**
   * Store earnings calendar data in database
   */
  async storeEarningsCalendar(earnings: EarningsCalendar[]): Promise<void> {
    try {
      for (const earning of earnings) {
        await this.db.query(`
          INSERT INTO earnings_calendar (
            symbol, company_name, earnings_date, time_of_day, fiscal_quarter, fiscal_year,
            eps_estimate, revenue_estimate, eps_actual, revenue_actual,
            importance_rating, confirmed, status, market_cap, previous_close,
            data_source, external_id, last_updated
          ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
          )
          ON CONFLICT (symbol, earnings_date, fiscal_quarter, fiscal_year)
          DO UPDATE SET
            company_name = EXCLUDED.company_name,
            time_of_day = EXCLUDED.time_of_day,
            eps_estimate = EXCLUDED.eps_estimate,
            revenue_estimate = EXCLUDED.revenue_estimate,
            eps_actual = EXCLUDED.eps_actual,
            revenue_actual = EXCLUDED.revenue_actual,
            importance_rating = EXCLUDED.importance_rating,
            confirmed = EXCLUDED.confirmed,
            status = EXCLUDED.status,
            market_cap = EXCLUDED.market_cap,
            previous_close = EXCLUDED.previous_close,
            last_updated = EXCLUDED.last_updated
        `, [
          earning.symbol,
          earning.company_name,
          earning.earnings_date,
          earning.time_of_day,
          earning.fiscal_quarter,
          earning.fiscal_year,
          earning.eps_estimate,
          earning.revenue_estimate,
          earning.eps_actual,
          earning.revenue_actual,
          earning.importance_rating,
          earning.confirmed,
          earning.status,
          earning.market_cap,
          earning.previous_close,
          earning.data_source,
          earning.external_id,
          earning.last_updated
        ]);
      }

      logger.info(`Stored ${earnings.length} earnings calendar entries`);
    } catch (error) {
      logger.error('Error storing earnings calendar', error);
      throw error;
    }
  }

  /**
   * Fetch SEC filing data for a specific company and date
   */
  async fetchSecFilings(
    cik: string,
    filingDate: string,
    filingTypes: string[] = ['10-Q', '10-K', '8-K']
  ): Promise<any[]> {
    try {
      // SEC EDGAR API endpoint
      const baseUrl = 'https://data.sec.gov/submissions';
      const url = `${baseUrl}/CIK${cik.padStart(10, '0')}.json`;

      const response = await fetch(url, {
        headers: {
          'User-Agent': 'Silver Fin Monitor earnings@silverfinmonitor.com',
          'Accept': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`SEC API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      // Filter filings by date and type
      const filings = data.filings?.recent;
      if (!filings) return [];

      const relevantFilings = [];
      for (let i = 0; i < filings.accessionNumber.length; i++) {
        const filing = {
          accessionNumber: filings.accessionNumber[i],
          filingDate: filings.filingDate[i],
          form: filings.form[i],
          primaryDocument: filings.primaryDocument[i],
          primaryDocDescription: filings.primaryDocDescription[i]
        };

        // Check if filing is within date range (Â±7 days) and correct type
        const filing_date = new Date(filing.filingDate);
        const target_date = new Date(filingDate);
        const daysDiff = Math.abs((filing_date.getTime() - target_date.getTime()) / (1000 * 3600 * 24));

        if (daysDiff <= 7 && filingTypes.includes(filing.form)) {
          relevantFilings.push(filing);
        }
      }

      return relevantFilings;
    } catch (error) {
      logger.error('Error fetching SEC filings', error);
      throw error;
    }
  }

  /**
   * Fetch and process SEC filing content
   */
  async fetchFilingContent(accessionNumber: string, primaryDocument: string): Promise<string> {
    try {
      // Construct the SEC document URL
      const cleanAccession = accessionNumber.replace(/-/g, '');
      const url = `https://www.sec.gov/Archives/edgar/data/${cleanAccession}/${accessionNumber}/${primaryDocument}`;

      const response = await fetch(url, {
        headers: {
          'User-Agent': 'Silver Fin Monitor earnings@silverfinmonitor.com'
        }
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch filing content: ${response.status}`);
      }

      const htmlContent = await response.text();
      
      // Extract text from HTML (basic implementation)
      const textContent = this.extractTextFromHtml(htmlContent);
      
      return textContent;
    } catch (error) {
      logger.error('Error fetching filing content', error);
      throw error;
    }
  }

  /**
   * Store SEC filing as earnings report
   */
  async storeEarningsReport(
    earningsCalendarId: string,
    filing: any,
    content: string,
    cik: string
  ): Promise<string> {
    try {
      const result = await this.db.query(`
        INSERT INTO earnings_reports (
          earnings_calendar_id, filing_type, filing_date, accession_number,
          cik, document_text, processing_status
        ) VALUES ($1, $2, $3, $4, $5, $6, 'pending')
        RETURNING id
      `, [
        earningsCalendarId,
        filing.form,
        filing.filingDate,
        filing.accessionNumber,
        cik,
        content
      ]);

      const reportId = result[0].id;
      
      // Queue AI processing job
      await this.queueReportProcessing(reportId);
      
      logger.info(`Stored earnings report ${reportId} for filing ${filing.accessionNumber}`);
      return reportId;
    } catch (error) {
      logger.error('Error storing earnings report', error);
      throw error;
    }
  }

  /**
   * Get earnings calendar with filters
   */
  async getEarningsCalendar(
    filters: EarningsCalendarFilters = {},
    limit: number = 100,
    offset: number = 0
  ): Promise<EarningsCalendarWithStats[]> {
    try {
      let whereClause = 'WHERE 1=1';
      const params: any[] = [];
      let paramIndex = 1;

      if (filters.symbol) {
        whereClause += ` AND symbol = $${paramIndex++}`;
        params.push(filters.symbol);
      }

      if (filters.start_date) {
        whereClause += ` AND earnings_date >= $${paramIndex++}`;
        params.push(filters.start_date);
      }

      if (filters.end_date) {
        whereClause += ` AND earnings_date <= $${paramIndex++}`;
        params.push(filters.end_date);
      }

      if (filters.importance_min) {
        whereClause += ` AND importance_rating >= $${paramIndex++}`;
        params.push(filters.importance_min);
      }

      if (filters.status) {
        whereClause += ` AND status = $${paramIndex++}`;
        params.push(filters.status);
      }

      if (filters.confirmed_only) {
        whereClause += ` AND confirmed = true`;
      }

      const query = `
        SELECT * FROM earnings_calendar_with_stats
        ${whereClause}
        ORDER BY earnings_date ASC, importance_rating DESC
        LIMIT $${paramIndex++} OFFSET $${paramIndex++}
      `;

      params.push(limit, offset);

      const results = await this.db.query(query, params);
      return results;
    } catch (error) {
      logger.error('Error getting earnings calendar', error);
      throw error;
    }
  }

  /**
   * Get comprehensive earnings data including reports
   */
  async getEarningsWithReports(symbol: string, earningsDate: string): Promise<any> {
    try {
      const result = await this.db.query(
        'SELECT get_earnings_with_reports($1, $2) as data',
        [symbol, earningsDate]
      );

      return result[0]?.data || null;
    } catch (error) {
      logger.error('Error getting earnings with reports', error);
      throw error;
    }
  }

  /**
   * Process earnings report with AI
   */
  async processEarningsReport(reportId: string): Promise<void> {
    try {
      // Get report content
      const report = await this.db.query(
        'SELECT * FROM earnings_reports WHERE id = $1',
        [reportId]
      );

      if (report.length === 0) {
        throw new Error(`Report ${reportId} not found`);
      }

      const reportData = report[0];
      
      // Update status to processing
      await this.db.query(
        'UPDATE earnings_reports SET processing_status = $1 WHERE id = $2',
        ['processing', reportId]
      );

      // Extract sections
      const sections = this.extractReportSections(reportData.document_text);
      
      // Store sections
      for (const section of sections) {
        await this.db.query(`
          INSERT INTO earnings_report_sections (
            earnings_report_id, section_type, section_title, section_content, section_order
          ) VALUES ($1, $2, $3, $4, $5)
        `, [reportId, section.type, section.title, section.content, section.order]);
      }

      // Queue AI analysis (implement based on your AI service)
      // await this.analyzeReportWithAI(reportId);

      // Update status to completed
      await this.db.query(
        'UPDATE earnings_reports SET processing_status = $1, processed_at = NOW() WHERE id = $2',
        ['completed', reportId]
      );

      logger.info(`Processed earnings report ${reportId}`);
    } catch (error) {
      logger.error('Error processing earnings report', error);
      
      // Update status to failed
      await this.db.query(
        'UPDATE earnings_reports SET processing_status = $1 WHERE id = $2',
        ['failed', reportId]
      );
      
      throw error;
    }
  }

  // Helper methods

  private mapTimeOfDay(timeOfDay?: string): 'before_market' | 'after_market' | 'during_market' | undefined {
    switch (timeOfDay?.toLowerCase()) {
      case 'before market open':
      case 'before_market':
        return 'before_market';
      case 'after market close':
      case 'after_market':
        return 'after_market';
      case 'during market hours':
      case 'during_market':
        return 'during_market';
      default:
        return undefined;
    }
  }

  private extractTextFromHtml(html: string): string {
    // Basic HTML to text conversion
    // In production, use a proper HTML parser like jsdom or cheerio
    return html
      .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
      .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
      .replace(/<[^>]*>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  private extractReportSections(text: string): Array<{
    type: string;
    title: string;
    content: string;
    order: number;
  }> {
    // Basic section extraction - implement proper parsing logic
    const sections = [];
    
    // Look for common section patterns
    const sectionPatterns = [
      { type: 'md_a', pattern: /MANAGEMENT.S DISCUSSION AND ANALYSIS/i },
      { type: 'risk_factors', pattern: /RISK FACTORS/i },
      { type: 'business', pattern: /BUSINESS/i },
      { type: 'financial_statements', pattern: /CONSOLIDATED STATEMENTS/i }
    ];

    for (let i = 0; i < sectionPatterns.length; i++) {
      const pattern = sectionPatterns[i];
      const match = text.match(pattern.pattern);
      if (match) {
        sections.push({
          type: pattern.type,
          title: match[0],
          content: text.substring(match.index || 0, (match.index || 0) + 5000), // First 5000 chars
          order: i + 1
        });
      }
    }

    return sections;
  }

  private async queueReportProcessing(reportId: string): Promise<void> {
    // Queue processing job using your existing queue system
    await this.db.query(`
      INSERT INTO job_queue (job_type, payload, priority)
      VALUES ('earnings_report_process', $1, 3)
    `, [JSON.stringify({ reportId })]);
  }
}

export default EarningsService;