import { Database } from '@/types/database';
import { EarningsCalendar, EarningsReport } from '@/types/earnings';
import { logger } from '@/utils/logger';

interface SecSubmission {
  accessionNumber: string[];
  filingDate: string[];
  form: string[];
  primaryDocument: string[];
  primaryDocDescription: string[];
  reportDate: string[];
  act: string[];
  fileNumber: string[];
  filmNumber: string[];
  items: string[];
  size: number[];
  isXBRL: number[];
  isInlineXBRL: number[];
  acceptanceDateTime: string[];
}

interface SecCompanyData {
  cik: string;
  entityType: string;
  sic: string;
  sicDescription: string;
  name: string;
  tickers: string[];
  exchanges: string[];
  ein: string;
  description: string;
  website: string;
  category: string;
  fiscalYearEnd: string;
  stateOfIncorporation: string;
  stateOfIncorporationDescription: string;
  addresses: any;
  phone: string;
  flags: string;
  formerNames: any[];
  filings: {
    recent: SecSubmission;
    files?: any[];
  };
}

export class SecEarningsService {
  private db: Database;
  private baseUrl = 'https://data.sec.gov';
  private userAgent = 'Silver Fin Monitor earnings@silverfinmonitor.com';

  constructor(db: Database) {
    this.db = db;
  }

  /**
   * Get company CIK from ticker symbol
   */
  async getCompanyCik(ticker: string): Promise<string | null> {
    try {
      // Use SEC company tickers JSON file
      const response = await fetch(`${this.baseUrl}/files/company_tickers.json`, {
        headers: { 'User-Agent': this.userAgent }
      });

      if (!response.ok) {
        throw new Error(`SEC API error: ${response.status}`);
      }

      const companies = await response.json();
      
      // Find company by ticker
      for (const [key, company] of Object.entries(companies as Record<string, any>)) {
        if (company.ticker?.toUpperCase() === ticker.toUpperCase()) {
          return company.cik_str.toString().padStart(10, '0');
        }
      }

      return null;
    } catch (error) {
      logger.error(`Error getting CIK for ${ticker}:`, error);
      return null;
    }
  }

  /**
   * Get recent earnings-related filings for a company
   */
  async getEarningsFilings(ticker: string, lookbackDays: number = 90): Promise<EarningsCalendar[]> {
    try {
      const cik = await this.getCompanyCik(ticker);
      if (!cik) {
        logger.warn(`CIK not found for ticker ${ticker}`);
        return [];
      }

      // Get company submission data
      const response = await fetch(`${this.baseUrl}/submissions/CIK${cik}.json`, {
        headers: { 'User-Agent': this.userAgent }
      });

      if (!response.ok) {
        throw new Error(`SEC API error: ${response.status}`);
      }

      const data = await response.json() as SecCompanyData;
      const filings = data.filings.recent;
      
      if (!filings) {
        return [];
      }

      const earningsCalendar: EarningsCalendar[] = [];
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - lookbackDays);

      // Process recent filings
      for (let i = 0; i < filings.form.length; i++) {
        const form = filings.form[i];
        const filingDate = filings.filingDate[i];
        
        // Only process earnings-related forms
        if (!['10-Q', '10-K', '8-K'].includes(form)) {
          continue;
        }

        const filing_date = new Date(filingDate);
        if (filing_date < cutoffDate) {
          continue;
        }

        // Determine fiscal quarter from form and filing date
        const { quarter, year } = this.determineFiscalPeriod(form, filing_date, data.fiscalYearEnd);

        const earningsEntry: EarningsCalendar = {
          id: '', // Will be generated by database
          symbol: ticker.toUpperCase(),
          company_name: data.name,
          earnings_date: filingDate,
          time_of_day: 'after_market', // Most filings are after market
          fiscal_quarter: quarter,
          fiscal_year: year,
          confirmed: true, // SEC filings are always confirmed
          status: 'reported', // SEC filings mean already reported
          data_source: 'sec_edgar',
          external_id: `${ticker}_${filingDate}_${form}`,
          last_updated: new Date().toISOString(),
          created_at: new Date().toISOString()
        };

        earningsCalendar.push(earningsEntry);
      }

      return earningsCalendar;
    } catch (error) {
      logger.error(`Error getting earnings filings for ${ticker}:`, error);
      throw error;
    }
  }

  /**
   * Fetch and store earnings report content
   */
  async fetchEarningsReport(
    earningsCalendarId: string,
    ticker: string,
    filingDate: string,
    formType: string
  ): Promise<string | null> {
    try {
      const cik = await this.getCompanyCik(ticker);
      if (!cik) return null;

      // Get submission data to find the specific filing
      const response = await fetch(`${this.baseUrl}/submissions/CIK${cik}.json`, {
        headers: { 'User-Agent': this.userAgent }
      });

      const data = await response.json() as SecCompanyData;
      const filings = data.filings.recent;

      // Find the specific filing
      let accessionNumber = '';
      let primaryDocument = '';

      for (let i = 0; i < filings.form.length; i++) {
        if (filings.form[i] === formType && filings.filingDate[i] === filingDate) {
          accessionNumber = filings.accessionNumber[i];
          primaryDocument = filings.primaryDocument[i];
          break;
        }
      }

      if (!accessionNumber) {
        logger.warn(`Filing not found: ${ticker} ${formType} ${filingDate}`);
        return null;
      }

      // Download the filing content
      const documentUrl = `${this.baseUrl}/Archives/edgar/data/${parseInt(cik)}/${accessionNumber}/${primaryDocument}`;
      
      const docResponse = await fetch(documentUrl, {
        headers: { 'User-Agent': this.userAgent }
      });

      if (!docResponse.ok) {
        throw new Error(`Failed to fetch document: ${docResponse.status}`);
      }

      const htmlContent = await docResponse.text();
      const textContent = this.extractTextFromHtml(htmlContent);

      // Store the report
      const reportId = await this.storeEarningsReport(
        earningsCalendarId,
        formType,
        filingDate,
        accessionNumber,
        cik,
        documentUrl,
        textContent
      );

      logger.info(`Stored earnings report ${reportId} for ${ticker} ${formType}`);
      return reportId;
    } catch (error) {
      logger.error(`Error fetching earnings report for ${ticker}:`, error);
      return null;
    }
  }

  /**
   * Store earnings report in database
   */
  private async storeEarningsReport(
    earningsCalendarId: string,
    filingType: string,
    filingDate: string,
    accessionNumber: string,
    cik: string,
    documentUrl: string,
    textContent: string
  ): Promise<string> {
    const result = await (this.db as any).query(`
      INSERT INTO earnings_reports (
        earnings_calendar_id, filing_type, filing_date, accession_number,
        cik, document_url, document_text, processing_status
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, 'completed')
      RETURNING id
    `, [
      earningsCalendarId,
      filingType,
      filingDate,
      accessionNumber,
      cik,
      documentUrl,
      textContent
    ]);

    return result[0].id;
  }

  /**
   * Process all major tickers for recent earnings
   */
  async processRecentEarnings(tickers: string[] = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX']): Promise<void> {
    try {
      logger.info('Processing recent earnings for major tickers');

      for (const ticker of tickers) {
        try {
          // Get earnings calendar entries
          const earningsEntries = await this.getEarningsFilings(ticker, 90);
          
          if (earningsEntries.length === 0) {
            logger.info(`No recent earnings found for ${ticker}`);
            continue;
          }

          // Store calendar entries
          for (const entry of earningsEntries) {
            await this.storeEarningsCalendar(entry);
            
            // Fetch the actual report
            const calendarId = await this.getEarningsCalendarId(entry.symbol, entry.earnings_date);
            if (calendarId) {
              await this.fetchEarningsReport(
                calendarId,
                entry.symbol,
                entry.earnings_date,
                entry.external_id?.split('_')[2] || '10-Q'
              );
            }
          }

          logger.info(`Processed ${earningsEntries.length} earnings entries for ${ticker}`);
          
          // Rate limiting - SEC allows 10 requests per second
          await this.sleep(150);
        } catch (error) {
          logger.error(`Error processing earnings for ${ticker}:`, error);
          continue;
        }
      }

      logger.info('Completed processing recent earnings');
    } catch (error) {
      logger.error('Error in processRecentEarnings:', error);
      throw error;
    }
  }

  /**
   * Store earnings calendar entry
   */
  private async storeEarningsCalendar(earning: EarningsCalendar): Promise<void> {
    await (this.db as any).query(`
      INSERT INTO earnings_calendar (
        symbol, company_name, earnings_date, time_of_day, fiscal_quarter, fiscal_year,
        confirmed, status, data_source, external_id, last_updated
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      ON CONFLICT (symbol, earnings_date, fiscal_quarter, fiscal_year)
      DO UPDATE SET
        company_name = EXCLUDED.company_name,
        time_of_day = EXCLUDED.time_of_day,
        confirmed = EXCLUDED.confirmed,
        status = EXCLUDED.status,
        last_updated = EXCLUDED.last_updated
    `, [
      earning.symbol,
      earning.company_name,
      earning.earnings_date,
      earning.time_of_day,
      earning.fiscal_quarter,
      earning.fiscal_year,
      earning.confirmed,
      earning.status,
      earning.data_source,
      earning.external_id,
      earning.last_updated
    ]);
  }

  /**
   * Get earnings calendar ID for linking reports
   */
  private async getEarningsCalendarId(symbol: string, earningsDate: string): Promise<string | null> {
    const result = await (this.db as any).query(
      'SELECT id FROM earnings_calendar WHERE symbol = $1 AND earnings_date = $2 LIMIT 1',
      [symbol, earningsDate]
    );

    return result[0]?.id || null;
  }

  // Helper methods

  private determineFiscalPeriod(formType: string, filingDate: Date, fiscalYearEnd: string): { quarter: 'Q1' | 'Q2' | 'Q3' | 'Q4', year: number } {
    const year = filingDate.getFullYear();
    
    if (formType === '10-K') {
      return { quarter: 'Q4', year };
    }

    // For 10-Q, determine quarter based on filing date and fiscal year end
    const month = filingDate.getMonth() + 1; // 1-12
    
    if (month >= 1 && month <= 3) {
      return { quarter: 'Q1', year };
    } else if (month >= 4 && month <= 6) {
      return { quarter: 'Q2', year };
    } else if (month >= 7 && month <= 9) {
      return { quarter: 'Q3', year };
    } else {
      return { quarter: 'Q4', year };
    }
  }

  private extractTextFromHtml(html: string): string {
    return html
      .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
      .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
      .replace(/<[^>]*>/g, ' ')
      .replace(/\s+/g, ' ')
      .replace(/&nbsp;/g, ' ')
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .trim();
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

export default SecEarningsService;